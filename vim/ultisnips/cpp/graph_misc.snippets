# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly ${1} = new Emitter<$2>()
#		public readonly ${1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt




snippet dfs_it "Iterative DFS" b
bool dfs(int start, int n, vt<pll> adj[]) {

    stack<int> s;
    vt<bool> visited(n, false);

    s.push(start);

    while (!s.empty()) {
        int a = s.top();
        s.pop();
        if (visited[a])
            continue;
        visited[a] = true;
		
		// process node here
		
        EACH(u, adj[a]) {
            int b = u.F;
            s.push(b);
        }
    }

    return false;
}
endsnippet

snippet union_find "Union Find with Rank and Path reduction" b

template <class Container, class T = int> struct union_find {

    Container parent;

    typedef
        typename conditional<is_same<Container, vector<T>>::value, vector<T>,
                             unordered_map<T, int>>::type Rank_Container;

    Rank_Container rank;

    template <typename C = Container,
              typename = typename enable_if<is_same<C, vector<T>>::value>::type,
              typename = C>
    union_find(int n) {
        for (int i = 0; i < n; i++) {
            parent.pb(i);
            rank.pb(0);
        }
    }

    template <typename C = Container,
              typename = typename enable_if<
                  is_same<C, unordered_map<T, T>>::value>::type,
              typename = C>
    union_find(vt<T> nodes) {
        for (auto c : nodes) {
            parent[c] = c;
            rank[c] = 0;
        }
    }

    T find(T k) {
        if (parent[k] != k) {
            parent[k] = find(parent[k]);
        }
        return parent[k];
    }

    void join(T a, T b) {
        T x = find(a);
        T y = find(b);

        if (x == y) {
            return;
        }

        if(rank[x] < rank[y])
			swap(x, y);

		parent[y] = x;
		if(rank[x] == rank[y])
			rank[x]++;
    }
    int size() { return sz(parent); }
};
endsnippet




snippet 2SAT "2 - Satifiability using Kosaraju algorithm for SCC" b

// import kosaraju

int neg(int x, int n) { return (x < n) ? x + n : x - n; }

int get_truth_value(int x, int n) { return x < n; }

bool solve_2SAT(int n, vt<int> adj[], vt<bool> &solution) {

    vt<vt<int>> scc;
    kosaraju(2 * n, adj, scc);
    EACH(c, scc)
    dbg(c);
    vt<int> comp_id(2 * n, -1);
    int num_comp = 0;

    EACH(c, scc) {
        EACH(v, c)
        comp_id[v] = num_comp;
        ++num_comp;
    }

    FOR(n)
    if (comp_id[i] == comp_id[neg(i, n)])
        return false;
    else
        solution[i] = comp_id[i] > comp_id[neg(i, n)];

    return true;
}
endsnippet
