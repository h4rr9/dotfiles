# A valid snippet should starts with:
#
#		snippet trigger_word [ "description" [ options ] ]
#
# and end with:
#
#		endsnippet
#
# Snippet options:
#
#		b - Beginning of line.
#		i - In-word expansion.
#		w - Word boundary.
#		r - Regular expression
#		e - Custom context snippet
#		A - Snippet will be triggered automatically, when condition matches.
#
# Basic example:
#
#		snippet emitter "emitter properties" b
#		private readonly ${1} = new Emitter<$2>()
#		public readonly ${1/^_(.*)/$1/}: Event<$2> = this.$1.event
#		endsnippet
#
# Online reference: https://github.com/SirVer/ultisnips/blob/master/doc/UltiSnips.txt




snippet dfs_it "Iterative DFS" b
bool dfs(int start, int n, vt<pll> adj[]) {

    stack<int> s;
    vt<bool> visited(n, false);

    s.push(start);

    while (!s.empty()) {
        int a = s.top();
        s.pop();
        if (visited[a])
            continue;
        visited[a] = true;
		
		// process node here
		
        EACH(u, adj[a]) {
            int b = u.F;
            s.push(b);
        }
    }

    return false;
}
endsnippet

snippet union_find "Union Find with Rank and Path reduction" b

template <class Container, class T = int> struct union_find {

    Container parent;

    typedef
        typename conditional<is_same<Container, vector<T>>::value, vector<T>,
                             unordered_map<T, int>>::type Rank_Container;

    Rank_Container rank;

    template <typename C = Container,
              typename = typename enable_if<is_same<C, vector<T>>::value>::type,
              typename = C>
    union_find(int n) {
        for (int i = 0; i < n; i++) {
            parent.pb(i);
            rank.pb(0);
        }
    }

    template <typename C = Container,
              typename = typename enable_if<
                  is_same<C, unordered_map<T, T>>::value>::type,
              typename = C>
    union_find(vt<T> nodes) {
        for (auto c : nodes) {
            parent[c] = c;
            rank[c] = 0;
        }
    }

    T find(T k) {
        if (parent[k] != k) {
            parent[k] = find(parent[k]);
        }
        return parent[k];
    }

    void join(T a, T b) {
        T x = find(a);
        T y = find(b);

        if (x == y) {
            return;
        }

        if(rank[x] < rank[y])
			swap(x, y);

		parent[y] = x;
		if(rank[x] == rank[y])
			rank[x]++;
    }
    int size() { return sz(parent); }
};
endsnippet




snippet 2SAT "2 - Satifiability using Kosaraju algorithm for SCC" b

// import kosaraju

int neg(int x, int n) { return (x < n) ? x + n : x - n; }

int get_truth_value(int x, int n) { return x < n; }

bool solve_2SAT(int n, vt<int> adj[], vt<bool> &solution) {

    vt<vt<int>> scc;
    kosaraju(2 * n, adj, scc);
    EACH(c, scc)
    dbg(c);
    vt<int> comp_id(2 * n, -1);
    int num_comp = 0;

    EACH(c, scc) {
        EACH(v, c)
        comp_id[v] = num_comp;
        ++num_comp;
    }

    FOR(n)
    if (comp_id[i] == comp_id[neg(i, n)])
        return false;
    else
        solution[i] = comp_id[i] > comp_id[neg(i, n)];

    return true;
}
endsnippet

snippet heirholzer_undirected "Eulerian path for undirected graph" b

void dfs(int node, vt<int> adj[], vt<bool> &visited) {
    if (visited[node])
        return;

    visited[node] = true;

    EACH(c_node, adj[node])
    dfs(c_node, adj, visited);
}

bool heirholzer(int n, vt<int> adj[], vt<int> &eulerian_circuit) {

    vt<int> degree(n, 0);
    FOR(node, n) { degree[node] += sz(adj[node]); }

    // circuit --  check if out_degee in equal to indegree
    //
    //
    // path -- check if one node has extra degree and another node has extra
    // degree and check if degree is equal to degree for other nodes

    FOR(n)
    if (1 & degree[i])
        return false;

    vt<bool> visited(n, false);

    dfs(0, adj, visited);

    FOR(n)
    if (!visited[i] and degree[i] > 0)
        return false;

    // heirholzer begins

    vt<int> adj_copy[n];

    FOR(n) {
        sort(all(adj[i]));
        adj_copy[i] = adj[i];
    }

    stack<int> s;
    s.push(0);

    while (!s.empty()) {
        int v = s.top();

        if (degree[v] == 0 and degree[v] == 0) {
            eulerian_circuit.pb(v);
            s.pop();
        } else {
            int node = adj_copy[v][degree[v] - 1];

            adj_copy[v].pop_back();
            adj_copy[node].erase(lower_bound(all(adj_copy[node]), v));

            --degree[v];
            --degree[node];

            s.push(node);
        }
    }

    return true;
}
endsnippet


snippet heirholzer_directed "Eulerian circuit for directed graph" b

bool heirholzer(int n, vt<int> adj[], vt<int> &eulerian_circuit) {

    vt<int> in_degree(n, 0), out_degree(n, 0);
    FOR(node, n) {
        out_degree[node] += sz(adj[node]);
        EACH(c_node, adj[node])
        ++in_degree[c_node];
    }
    // circuit --  check if out_degee in equal to indegree
    //
    //
    // path -- check if one node has extra degree and another node has extra
    // degree and check if degree is equal to degree for other nodes

    FOR(n)
    if (in_degree != out_degree)
        return false;
    // heirholzer begins

    vt<int> adj_copy[n];

    FOR(n) { adj_copy[i] = adj[i]; }

    stack<int> s;
    s.push(0);

    while (!s.empty()) {
        int v = s.top();

        if (out_degree[v] == 0) {
            eulerian_circuit.pb(v);
            s.pop();
        } else {
            int node = adj_copy[v][out_degree[v] - 1];

            adj_copy[v].pop_back();

            --out_degree[v];
            --in_degree[node];

            s.push(node);
        }
    }

    return true;
}
endsnippet


snippet hamiltonian_path "counting hamiltonian path" b

int hamiltonian_path_count(int n, vt<int> rev_adj[]) { // directed graph

    auto bit = [](int i, int mask) { return (1 << i) & mask; };

    int num_nodes =
        (1 << (n - 1)); // solve for n-1 nodes and do last node indepenantly

    vt<vt<int>> dp(num_nodes, vt<int>(n, 0));
    dp[1][0] = 1;

    FOR(mask, num_nodes) { // solving for n-1 nodes
        FOR(node, n - 1) {
            if (bit(node, mask)) {
                EACH(p_node, rev_adj[node]) {
                    if (bit(p_node, mask)) {
                        (dp[mask][node] += dp[mask ^ (1 << node)][p_node]) %=
                            MOD;
                    }
                }
            }
        }
    }

    int mask = (1 << n) - 1;
    int ans = 0;
    EACH(p_node, rev_adj[n - 1]) { // know answer for n-1 nodes and hamiltonian
                                   // path must end at node n-1.
        (ans += dp[mask ^ (1 << (n - 1))][p_node]) %= MOD;
    }

    return ans;
}
endsnippet
